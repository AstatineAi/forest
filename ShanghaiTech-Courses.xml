<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>602</fr:anchor><fr:addr
type="user">ShanghaiTech-Courses</fr:addr><fr:route>ShanghaiTech-Courses.xml</fr:route><fr:title
text="Courses">Courses</fr:title><fr:authors><fr:author><fr:link
type="local"
href="astinita.xml"
addr="astinita"
title="Hengyu Ai">Hengyu Ai</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:ul><fr:li><fr:link
type="local"
href="ShanghaiTech-CS101-index.xml"
addr="ShanghaiTech-CS101-index"
title="Courses › Algorithm &amp; DS Fall 2024">Algorithm &amp; Data Structures Fall 2024</fr:link></fr:li>

<fr:li><fr:link
type="local"
href="ShanghaiTech-SI140A-index.xml"
addr="ShanghaiTech-SI140A-index"
title="Courses › Probability &amp; Statistics for EECS Fall 2024">Probability &amp; Statistics for EECS Fall 2024</fr:link></fr:li></fr:ul></fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Context">Context</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>604</fr:anchor><fr:addr
type="user">index</fr:addr><fr:route>index.xml</fr:route><fr:title
text="Thought Cabinet">Thought Cabinet</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>This is a simple collection of
  <fr:ul><fr:li>Interesting things I heard about (collect them to deal with "citation needed")</fr:li>
    <fr:li>Some notes on course content/course project/books.</fr:li>
    <fr:li>Other random thoughts from my brain.</fr:li></fr:ul></fr:p><fr:p>This website is a <fr:link
type="external"
href="https://www.jonmsterling.com/foreign-forester-tfmt-000V.xml">“forest”</fr:link> created using the <fr:link
type="external"
href="https://www.jonmsterling.com/foreign-forester-index.xml">Forester</fr:link> tool. To navigate this forest, press <fr:code>Ctrl + K</fr:code>.</fr:p><fr:p>The phrase <fr:em>Thought Cabinet</fr:em> is from the game <fr:link
type="external"
href="https://store.steampowered.com/app/632470/Disco_Elysium__The_Final_Cut/">Disco Elysium</fr:link>.</fr:p><fr:p>这个网站是一个由 <fr:link
type="external"
href="https://www.jonmsterling.com/foreign-forester-index.xml">Forester</fr:link> 工具构建的 <fr:link
type="external"
href="https://www.jonmsterling.com/foreign-forester-tfmt-000V.xml">“森林”</fr:link>。按 <fr:code>Ctrl + K</fr:code> 浏览全部内容的目录 &amp; 进行搜索。</fr:p><fr:p>网站的名字 <fr:em>Thought Cabinet</fr:em> 来自游戏 <fr:link
type="external"
href="https://store.steampowered.com/app/632470/Disco_Elysium__The_Final_Cut/">Disco Elysium</fr:link> 中的角色成长系统（之一）<fr:em>思维阁</fr:em>。</fr:p>
  <fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>605</fr:anchor><fr:addr
type="user">astinita</fr:addr><fr:route>astinita.xml</fr:route><fr:title
text="Hengyu Ai">Hengyu Ai</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta
name="institution"><fr:link
type="external"
href="https://www.shanghaitech.edu.cn/eng/">ShanghaiTech University</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Undergraduate @ ShanghaiTech University</fr:p><fr:p>如果这行中文 &amp; 下方的公式显示正常 &amp; 代码有高亮，说明网页加载正常。</fr:p><fr:tex
display="block"><![CDATA[   Y = \lambda  f. (\lambda  x. f (x x)) (\lambda  x. f (x x)) ]]></fr:tex>
  <fr:pre><html:code
xmlns:html="http://www.w3.org/1999/xhtml"
class="&quot;language-haskell&quot;">primes = filterPrime [2..] where
  filterPrime (p:xs) =
    p : filterPrime [x | x &lt;- xs, x `mod` p /= 0]
</html:code></fr:pre>
</fr:mainmatter><fr:backmatter /></fr:tree>

  <html:hr
xmlns:html="http://www.w3.org/1999/xhtml" />
<fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>606</fr:anchor><fr:addr
type="machine">#244</fr:addr><fr:route>unstable-244.xml</fr:route><fr:title
text="Random Ideas">Random Ideas</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>607</fr:anchor><fr:addr
type="user">random-idea-0003</fr:addr><fr:route>random-idea-0003.xml</fr:route><fr:title
text="有什么可担心的？">有什么可担心的？</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>你就想：</fr:p><fr:p>对面的那个人也是活人，</fr:p><fr:p>也会手冲。</fr:p><fr:p>差不多就行了，但是不要太详细的想他手冲。</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>608</fr:anchor><fr:addr
type="user">random-idea-0002</fr:addr><fr:route>random-idea-0002.xml</fr:route><fr:title
text="A &quot;Not Very Deep&quot; Insight">A "Not Very Deep" Insight</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="astinita.xml"
addr="astinita"
title="Hengyu Ai">Hengyu Ai</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>在线性代数里面我们已经理解了为什么 Gauss 消元/ Gauss-Jordan 消元就是：
  <fr:ul><fr:li>LU 分解</fr:li>
    <fr:li>解线性方程组</fr:li>
    <fr:li>求逆矩阵</fr:li>
    <fr:li>求行列式</fr:li></fr:ul></fr:p><fr:p>在算法课上我们了解了 Floyd-Warshall 算法就是传递闭包（的一个实现），而邻接矩阵的 <fr:tex
display="inline"><![CDATA[k]]></fr:tex> 次幂代表了节点之间长度恰好为 <fr:tex
display="inline"><![CDATA[k]]></fr:tex> 的路径的数量。</fr:p><fr:p>如果定义一些新的 "product"，Folyd-Warshall 也是一种矩阵乘法。</fr:p><fr:p>如果考虑其他“输入”和结果的集合，是否可以使用同一种描述来表示：
  <fr:ul><fr:li>LU 分解</fr:li>
    <fr:li>解线性方程组</fr:li>
    <fr:li>求逆矩阵</fr:li>
    <fr:li>求行列式</fr:li>
    <fr:li>Floyd-Warshall 算法</fr:li>
    <fr:li>传递闭包</fr:li>
    <fr:li>DFA &amp; NFA</fr:li>
    <fr:li>Markov 链</fr:li>
    <fr:li>齐次线性递推</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>610</fr:anchor><fr:addr
type="user">random-idea-0001</fr:addr><fr:route>random-idea-0001.xml</fr:route><fr:title
text="Essence, Reductionism and Abstraction Leak">Essence, Reductionism and Abstraction Leak</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="astinita.xml"
addr="astinita"
title="Hengyu Ai">Hengyu Ai</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Consider this question: To what extent can we say that the essence of one thing <fr:tex
display="inline"><![CDATA[x]]></fr:tex> is almost another thing <fr:tex
display="inline"><![CDATA[y]]></fr:tex>?</fr:p><fr:p>In algebra, we have:</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>471</fr:anchor><fr:addr
type="user">concept-0001</fr:addr><fr:route>concept-0001.xml</fr:route><fr:title
text="Equivalence Relation">Equivalence Relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>equivalence relation（等价关系）</fr:strong> is a binary relation <fr:tex
display="inline"><![CDATA[\equiv ]]></fr:tex> on a set <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, such that:

  <fr:ul><fr:li>reflexive: for all <fr:tex
display="inline"><![CDATA[x : S]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x \equiv  x]]></fr:tex></fr:li>
    <fr:li>symmetric: for all <fr:tex
display="inline"><![CDATA[x, y : S]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[x \equiv  y]]></fr:tex> then <fr:tex
display="inline"><![CDATA[y \equiv  x]]></fr:tex></fr:li>
    <fr:li>transitive: for all <fr:tex
display="inline"><![CDATA[x, y, z : S]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[x \equiv  y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y \equiv  z]]></fr:tex> then <fr:tex
display="inline"><![CDATA[x \equiv  z]]></fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Maybe we can say that <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex> share the same essence if and only if there exists an equivalence relation <fr:tex
display="inline"><![CDATA[\operatorname {R}]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[x \operatorname {R} y]]></fr:tex>.</fr:p><fr:p>Under this definition, we can find some interesting examples. For instance, Dijkstra's algorithm and Prim's algorithm both find a <fr:em>minimum</fr:em> among the un-visited stuff, and Dijkstra's algorithm is an A* graph search with heuristic function <fr:tex
display="inline"><![CDATA[h(v) = 0]]></fr:tex>.</fr:p><fr:p>However, it's not always to break concepts down to <fr:em>essence</fr:em>, especially we can't definitely say that everything has an essence.</fr:p><fr:p>From the perspective of computability, Dijkstra's algorithm is a turing machine that always halts, or some extremely complex lambda calculus terms that always reduces to a normal form. From the perspective of implementation and hardware, it's a collection of instructions that can be executed.</fr:p><fr:p>这种“回归本质”，或者说，还原主义的思维方式在理工科同学中并不少见，但是人心不足蛇吞象，尝试用本质描述一切就像是把大一统理论放在目标列表的第一项，总想着一口吃下整个思维过程。</fr:p><fr:p>It's unreasonable to conclude everything by assigning an essence to it. The context matters.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>472</fr:anchor><fr:addr
type="user">concept-0004</fr:addr><fr:route>concept-0004.xml</fr:route><fr:title
text="Abstraction Leak">Abstraction Leak</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Abstraction</fr:strong> is crucial for understanding complex systems. It is another layer above the concrete details. Ideally, we can order knowledge in a top-down approach, starting from the most abstract concepts and then diving into the details.</fr:p><fr:p>The not-so-ideal reality is that <fr:strong>asbtractions do not always have "proper generality"</fr:strong>. This means that in some cases we must deal with the details which the abstraction was supposed to hide. This is what we call an <fr:strong>abstraction leak</fr:strong>.</fr:p><fr:p>Abstraction leaks are not necessarily related to the implementation or hardware details. If an abstraction exagerates the generality of a concept, other things based on it may not work as expected.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree>
  
  <fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>612</fr:anchor><fr:addr
type="user">ShanghaiTech-Courses</fr:addr><fr:route>ShanghaiTech-Courses.xml</fr:route><fr:title
text="Courses">Courses</fr:title><fr:authors><fr:author><fr:link
type="local"
href="astinita.xml"
addr="astinita"
title="Hengyu Ai">Hengyu Ai</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:ul><fr:li><fr:link
type="local"
href="ShanghaiTech-CS101-index.xml"
addr="ShanghaiTech-CS101-index"
title="Courses › Algorithm &amp; DS Fall 2024">Algorithm &amp; Data Structures Fall 2024</fr:link></fr:li>

<fr:li><fr:link
type="local"
href="ShanghaiTech-SI140A-index.xml"
addr="ShanghaiTech-SI140A-index"
title="Courses › Probability &amp; Statistics for EECS Fall 2024">Probability &amp; Statistics for EECS Fall 2024</fr:link></fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Related">Related</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>614</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-index</fr:addr><fr:route>ShanghaiTech-SI140A-index.xml</fr:route><fr:title
text="Courses › Probability &amp; Statistics for EECS Fall 2024"><fr:link
type="local"
href="ShanghaiTech-Courses.xml"
addr="ShanghaiTech-Courses"
title="Courses">Courses</fr:link> › Probability &amp; Statistics for EECS Fall 2024</fr:title><fr:taxon>Course</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /><fr:meta
name="external">https://i-techx.github.io/iTechX/courses?course_code=SI140A</fr:meta></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="external"
href="ShanghaiTech-SI140A/Fall2024-HW-solutions.pdf">Homework solutions</fr:link></fr:p>
  <html:hr
xmlns:html="http://www.w3.org/1999/xhtml" />
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>551</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-Concepts</fr:addr><fr:route>ShanghaiTech-SI140A-Concepts.xml</fr:route><fr:title
text="Concepts and definitions">Concepts and definitions</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>267</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0002</fr:addr><fr:route>ShanghaiTech-SI140A-0002.xml</fr:route><fr:title
text="Properties of Variance">Properties of Variance</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:ul><fr:li>For any r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\operatorname {Var}(X) = E(X^2) - E(X)^2]]></fr:tex></fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[\operatorname {Var}(X + c) = \operatorname {Var}(X)]]></fr:tex></fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[\operatorname {Var}(cX) = c^2 \operatorname {Var}(X)]]></fr:tex></fr:li>
  <fr:li>If <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> are independent, then <fr:tex
display="inline"><![CDATA[\operatorname {Var}(X + Y) = \operatorname {Var}(X) + \operatorname {Var}(Y)]]></fr:tex></fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[\operatorname {Var}(X) \leq  0]]></fr:tex> with equality if and only if <fr:tex
display="inline"><![CDATA[P(X = a) = 1]]></fr:tex> for some constant <fr:tex
display="inline"><![CDATA[a]]></fr:tex></fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>268</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0003</fr:addr><fr:route>ShanghaiTech-SI140A-0003.xml</fr:route><fr:title
text="Continuous Random Variables">Continuous Random Variables</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>An r.v. has a <fr:strong>continuous distribution</fr:strong> if its CDF is differentiable. We also allow there to be endpoints (or finitely many points) where the CDF is continuous but not differentiable, as long as the CDF is differentiable everywhere else. A <fr:strong>continuous random variable</fr:strong> is a random variable with a continuous distribution.</fr:p><fr:p>Unlike PMF of a discrete r.v., the PDF of a continuous r.v. does not give the probability of a particular value.

  <fr:tex
display="block"><![CDATA[     P(X = x) = 0 \text { for all } x   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>269</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0004</fr:addr><fr:route>ShanghaiTech-SI140A-0004.xml</fr:route><fr:title
text="Probability Density Functions">Probability Density Functions</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For a continuous r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> with CDF <fr:tex
display="inline"><![CDATA[F_X(x)]]></fr:tex>, the <fr:strong>probability density function</fr:strong> (PDF, 概率密度函数) of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is defined as

  <fr:tex
display="block"><![CDATA[     f_X(x) = \frac {\mathrm {d}}{\mathrm {d}x} F_X(x)   ]]></fr:tex></fr:p><fr:p>Similarly, the <fr:strong>cumulative distribution function</fr:strong> (CDF, 累积分布函数) of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> can be obtained by integrating the PDF:

  <fr:tex
display="block"><![CDATA[     F_X(x) = \int _{-\infty }^x f_X(t) \; \mathrm {d}t   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>270</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0005</fr:addr><fr:route>ShanghaiTech-SI140A-0005.xml</fr:route><fr:title
text="Validity of Probability Density Functions">Validity of Probability Density Functions</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="ShanghaiTech-SI140A-0004.xml"
addr="ShanghaiTech-SI140A-0004"
title="Probability Density Functions">PDF</fr:link> of a continuous r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> must satisfy the following conditions:
  <fr:ul><fr:li><fr:strong>Non-negativity</fr:strong>: <fr:tex
display="inline"><![CDATA[f_X(x) \geq  0]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[x]]></fr:tex>.</fr:li>
    <fr:li><fr:strong>Normalization</fr:strong>: <fr:tex
display="inline"><![CDATA[\int _{-\infty }^\infty  f_X(x) \; \mathrm {d}x = 1]]></fr:tex>.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>271</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0006</fr:addr><fr:route>ShanghaiTech-SI140A-0006.xml</fr:route><fr:title
text="Law of the Unconscious Statisticians">Law of the Unconscious Statisticians</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Discrete Case</fr:strong>:
  <fr:tex
display="block"><![CDATA[     E(g(X)) = \sum _{x} g(x) P(X = x)   ]]></fr:tex></fr:p><fr:p><fr:strong>Continuous Case</fr:strong>:
  <fr:tex
display="block"><![CDATA[     E(g(X)) = \int _{-\infty }^\infty  g(x) f_X(x) \; \mathrm {d}x   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>272</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0007</fr:addr><fr:route>ShanghaiTech-SI140A-0007.xml</fr:route><fr:title
text="Standard Normal Distribution">Standard Normal Distribution</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A continuous r.v. <fr:tex
display="inline"><![CDATA[Z]]></fr:tex> is said to have a <fr:strong>standard normal distribution</fr:strong> if its PDF <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> is given by:

  <fr:tex
display="block"><![CDATA[     \varphi (z) = \frac {1}{\sqrt {2\pi }} e^{-z^2/2}   ]]></fr:tex></fr:p><fr:p>The <fr:strong>standard normal CDF</fr:strong> <fr:tex
display="inline"><![CDATA[\Phi ]]></fr:tex> is given by:
  
  <fr:tex
display="block"><![CDATA[     \Phi (z) = \int _{-\infty }^z \varphi (t) dt   ]]></fr:tex></fr:p><fr:p>Standard normal distribution is denoted by <fr:tex
display="inline"><![CDATA[Z \sim  N(0, 1)]]></fr:tex>. The expectation and variance of a standard normal r.v. are <fr:tex
display="inline"><![CDATA[0]]></fr:tex> and <fr:tex
display="inline"><![CDATA[1]]></fr:tex> respectively.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>273</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0008</fr:addr><fr:route>ShanghaiTech-SI140A-0008.xml</fr:route><fr:title
text="Normal Distribution">Normal Distribution</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[Z]]></fr:tex> is a r.v with <fr:link
type="local"
href="ShanghaiTech-SI140A-0007.xml"
addr="ShanghaiTech-SI140A-0007"
title="Standard Normal Distribution">standard normal distribution</fr:link>, then
  <fr:tex
display="block"><![CDATA[     X = \mu  + \sigma  Z   ]]></fr:tex>
  is said to have the <fr:strong>normal distribution</fr:strong> with mean <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex> and variance <fr:tex
display="inline"><![CDATA[\sigma ^2]]></fr:tex>.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[X \sim  N(\mu , \sigma ^2)]]></fr:tex>, the CDF of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is
  <fr:tex
display="block"><![CDATA[     F(x) = \Phi \left (\frac {x - \mu }{\sigma }\right )   ]]></fr:tex>
  where <fr:tex
display="inline"><![CDATA[\Phi ]]></fr:tex> is the CDF of the standard normal distribution.</fr:p><fr:p>The PDF of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is
  <fr:tex
display="block"><![CDATA[     f(x) = \frac {1}{\sigma } \varphi \left (\frac {x - \mu }{\sigma }\right )   ]]></fr:tex>
  where <fr:tex
display="inline"><![CDATA[\phi ]]></fr:tex> is the PDF of the standard normal distribution.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>274</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0009</fr:addr><fr:route>ShanghaiTech-SI140A-0009.xml</fr:route><fr:title
text="Central Limit Theorem">Central Limit Theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X_1, X_2, \ldots , X_n]]></fr:tex> be a sequence of i.i.d r.v with finite mean <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex> and variance <fr:tex
display="inline"><![CDATA[\sigma ^2]]></fr:tex>, the sample mean is defined as
  <fr:tex
display="block"><![CDATA[     \bar {X} = \frac {1}{n} \sum _{i=1}^n X_i   ]]></fr:tex>
  Then, as <fr:tex
display="inline"><![CDATA[n \to  \infty ]]></fr:tex>,

  <fr:tex
display="block"><![CDATA[     \sqrt {n} \left ( \frac {\bar {X} - \mu }{\sigma ^2} \right ) \to  N(0, 1)   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>275</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000A</fr:addr><fr:route>ShanghaiTech-SI140A-000A.xml</fr:route><fr:title
text="Moment Generating Functions">Moment Generating Functions</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>Moment Generating Function</fr:strong> (MGF) of a random variable <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is defined as

  <fr:tex
display="block"><![CDATA[     M(t) = E(e^{tX})   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>276</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000F</fr:addr><fr:route>ShanghaiTech-SI140A-000F.xml</fr:route><fr:title
text="Joint CDF">Joint CDF</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>joint cumulative distribution function</fr:strong> (CDF) of two random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is defined as

  <fr:tex
display="block"><![CDATA[     F_{X, Y}(x, y) = P(X \leq  x, Y \leq  y)   ]]></fr:tex>

  This can be extended to multiple random variables.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>277</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000G</fr:addr><fr:route>ShanghaiTech-SI140A-000G.xml</fr:route><fr:title
text="Joint PMF">Joint PMF</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>Joint PMF</fr:strong> of two discrete random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is defined as

  <fr:tex
display="block"><![CDATA[     p_{X,Y}(x,y) = \Pr (X = x, Y = y)   ]]></fr:tex>

  Joint PMF of multiple random variables can be defined similarly.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>278</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000H</fr:addr><fr:route>ShanghaiTech-SI140A-000H.xml</fr:route><fr:title
text="Marginal PMF">Marginal PMF</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For discrete r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, the marginal PMF of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is

  <fr:tex
display="block"><![CDATA[     P(X = x) = \sum _y P(X = x, Y = y)   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>279</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000I</fr:addr><fr:route>ShanghaiTech-SI140A-000I.xml</fr:route><fr:title
text="Conditional PMF">Conditional PMF</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For discrete r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, the conditional PMF of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> given <fr:tex
display="inline"><![CDATA[Y = y]]></fr:tex> is

  <fr:tex
display="block"><![CDATA[     P_{X \mid  Y}(x \mid  y) = P(X = x \mid  Y = y) = \frac {P(X = x, Y = y)}{P(Y = y)}   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>280</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000J</fr:addr><fr:route>ShanghaiTech-SI140A-000J.xml</fr:route><fr:title
text="Independence of Discrete R.V.s">Independence of Discrete R.V.s</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Discrete r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> are <fr:strong>independent</fr:strong> if
  <fr:tex
display="block"><![CDATA[     F_{X, Y}(x, y) = F_X(x) F_Y(y)   ]]></fr:tex>
  and it is also equivalent to the condition:
  <fr:tex
display="block"><![CDATA[     P(Y = y \mid  X = x) = P(Y = y)   ]]></fr:tex>
  for all <fr:tex
display="inline"><![CDATA[y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x]]></fr:tex> s.t. <fr:tex
display="inline"><![CDATA[P(X = x) > 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>281</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000K</fr:addr><fr:route>ShanghaiTech-SI140A-000K.xml</fr:route><fr:title
text="Related Theorem">Related Theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[X \sim  \operatorname {Pois}(\lambda  p)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y \sim  \operatorname {Pois}(\lambda  (1 - p))]]></fr:tex> are independent, then <fr:tex
display="inline"><![CDATA[X + Y \sim  \operatorname {Pois}(\lambda )]]></fr:tex> and <fr:tex
display="inline"><![CDATA[X \mid  (X + Y = n) \sim  \operatorname {Bin}(n, p)]]></fr:tex>.</fr:p><fr:p>If <fr:tex
display="inline"><![CDATA[N \sim  \operatorname {Pois}(\lambda )]]></fr:tex> and <fr:tex
display="inline"><![CDATA[X \mid  N = n \sim  \operatorname {Bin}(n, p)]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[X \sim  \operatorname {Pois}(\lambda  p)]]></fr:tex>, <fr:tex
display="inline"><![CDATA[Y = N - X \sim  \operatorname {Pois}(\lambda  (1 - p))]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> are independent.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>282</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000L</fr:addr><fr:route>ShanghaiTech-SI140A-000L.xml</fr:route><fr:title
text="Joint PDF">Joint PDF</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> are continuous with joint CDF <fr:tex
display="inline"><![CDATA[F_{X, Y}]]></fr:tex>, then the joint PDF of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is
  
  <fr:tex
display="block"><![CDATA[     f_{X, Y}(x, y) = \frac {\partial ^2 F_{X, Y}}{\partial  x \partial  y}   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>283</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000M</fr:addr><fr:route>ShanghaiTech-SI140A-000M.xml</fr:route><fr:title
text="Marginal PDF">Marginal PDF</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For continuous random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, the <fr:strong>marginal probability density function</fr:strong> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is

  <fr:tex
display="block"><![CDATA[     f_X(x) = \int _{-\infty }^\infty  f_{X, Y}(x, y) \; \mathrm {d}y   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>284</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000N</fr:addr><fr:route>ShanghaiTech-SI140A-000N.xml</fr:route><fr:title
text="Conditional PDF">Conditional PDF</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For continuous random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, the <fr:strong>conditional probability density function</fr:strong> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> given <fr:tex
display="inline"><![CDATA[Y = y]]></fr:tex> is

  <fr:tex
display="block"><![CDATA[     f_{X \mid  Y}(x \mid  y) = \frac {f_{X, Y}(x, y)}{f_Y(y)}   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>285</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000O</fr:addr><fr:route>ShanghaiTech-SI140A-000O.xml</fr:route><fr:title
text="Independence of Continuous R.V.s">Independence of Continuous R.V.s</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Continuous random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> are <fr:strong>independent</fr:strong> if:
  
  <fr:tex
display="block"><![CDATA[     f_{X, Y}(x, y) = f_X(x) f_Y(y)   ]]></fr:tex>

  It is also equivalent to:

  <fr:tex
display="block"><![CDATA[     f_{X \mid  Y}(x \mid  y) = f_X(x) \quad  \text {and} \quad  f_{Y \mid  X}(y \mid  x) = f_Y(y)   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>286</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000P</fr:addr><fr:route>ShanghaiTech-SI140A-000P.xml</fr:route><fr:title
text="2D LOTUS">2D LOTUS</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be two random variables, <fr:tex
display="inline"><![CDATA[g: \mathbb {R}^2 \mapsto  \mathbb {R}]]></fr:tex>, then:

  <fr:tex
display="block"><![CDATA[     E[g(X, Y)] = \int _{-\infty }^{+\infty } \int _{-\infty }^{+\infty } g(x, y) f_{X, Y}(x, y) \, \mathrm {d}x \, \mathrm {d}y   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>287</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000Q</fr:addr><fr:route>ShanghaiTech-SI140A-000Q.xml</fr:route><fr:title
text="Covariance">Covariance</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>covariance</fr:strong> of two random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is defined as

  <fr:tex
display="block"><![CDATA[     \operatorname {Cov} (X, Y) = E ((X - E(X)) (Y - E(Y))) = E(XY) - E(X) E(Y)   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>288</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000S</fr:addr><fr:route>ShanghaiTech-SI140A-000S.xml</fr:route><fr:title
text="Correlation">Correlation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>correlation</fr:strong> between two random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is

  <fr:tex
display="block"><![CDATA[     \operatorname {Corr} (X, Y) = \frac {\operatorname {Cov} (X, Y)}{\sqrt {\operatorname {Var} (X) \operatorname {Var} (Y)}}   ]]></fr:tex></fr:p><fr:p>For any two random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>:

  <fr:tex
display="block"><![CDATA[     -1 \leq  \operatorname {Corr} (X, Y) \leq  1   ]]></fr:tex>

  If <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> are independent, then <fr:tex
display="inline"><![CDATA[\operatorname {Corr} (X, Y) = 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>289</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000V</fr:addr><fr:route>ShanghaiTech-SI140A-000V.xml</fr:route><fr:title
text="Cauchy-Schwarz Inequality (Probability Theory)">Cauchy-Schwarz Inequality (Probability Theory)</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>290</fr:anchor><fr:addr
type="user">concept-000A</fr:addr><fr:route>concept-000A.xml</fr:route><fr:title
text="Cauchy-Schwarz Inequality">Cauchy-Schwarz Inequality</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>Cauchy-Schwarz inequality</fr:strong> states that for all vectors <fr:tex
display="inline"><![CDATA[\boldsymbol {a}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\boldsymbol {b}]]></fr:tex> in a inner product space, the following inequality holds:

  <fr:tex
display="block"><![CDATA[     \left | \langle  \boldsymbol {a}, \boldsymbol {b} \rangle  \right |^2 \leq  \langle  \boldsymbol {a}, \boldsymbol {a} \rangle  \cdot  \langle  \boldsymbol {b}, \boldsymbol {b} \rangle    ]]></fr:tex>

  where <fr:tex
display="inline"><![CDATA[\langle  \cdot , \cdot  \rangle ]]></fr:tex> is the inner product.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>In probability theory, we define an inner product between two random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> as

  <fr:tex
display="block"><![CDATA[     \langle  X, Y \rangle  = E (X Y)   ]]></fr:tex>

  the Cauchy-Schwarz inequality states that

  <fr:tex
display="block"><![CDATA[     |E(XY)| \leq  \sqrt {E(X^2) E(Y^2)}   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>291</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000W</fr:addr><fr:route>ShanghaiTech-SI140A-000W.xml</fr:route><fr:title
text="Markov's Inequality">Markov's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For any r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and constant <fr:tex
display="inline"><![CDATA[a > 0]]></fr:tex>, we have

  <fr:tex
display="block"><![CDATA[     P(|X| \geq  a) \leq  \frac {E|X|}{a}   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>292</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000X</fr:addr><fr:route>ShanghaiTech-SI140A-000X.xml</fr:route><fr:title
text="Chebyshev's Inequality">Chebyshev's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a r.v. with finite mean <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex> and finite variance <fr:tex
display="inline"><![CDATA[\sigma ^2]]></fr:tex>. Then for any constant <fr:tex
display="inline"><![CDATA[a > 0]]></fr:tex>, we have

  <fr:tex
display="block"><![CDATA[     P(|X - \mu | \geq  a) \leq  \frac {\sigma ^2}{a^2}   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>293</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000Y</fr:addr><fr:route>ShanghaiTech-SI140A-000Y.xml</fr:route><fr:title
text="Chernoff's Inequality">Chernoff's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For any r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and constants <fr:tex
display="inline"><![CDATA[a, t > 0]]></fr:tex>, we have

  <fr:tex
display="block"><![CDATA[     P(X \geq  a) \leq  \frac {E(e^{tX})}{e^{ta}}   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>294</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000Z</fr:addr><fr:route>ShanghaiTech-SI140A-000Z.xml</fr:route><fr:title
text="Hoeffding Bound">Hoeffding Bound</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let the r.v. s <fr:tex
display="inline"><![CDATA[X_1, X_2, \dots , X_n]]></fr:tex> be i.i.d. with <fr:tex
display="inline"><![CDATA[\E (X_i) = \mu ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[a \leq  X_i \leq  b]]></fr:tex>. Then, for any <fr:tex
display="inline"><![CDATA[\epsilon  > 0]]></fr:tex>,

  <fr:tex
display="block"><![CDATA[     P \left ( \left | \frac {1}{n} \sum _{i=1}^n X_i - \mu  \right | \geq  \epsilon  \right ) \leq  2 \exp  \left ( - \frac {2n \epsilon ^2}{(b-a)^2} \right )   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>295</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0011</fr:addr><fr:route>ShanghaiTech-SI140A-0011.xml</fr:route><fr:title
text="Law of Total Expectation">Law of Total Expectation</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X_1, X_2, \dots , X_n]]></fr:tex> be a partition of the sample space, s.t. <fr:tex
display="inline"><![CDATA[P(X_i) > 0]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[i]]></fr:tex>. Then for any random variable <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> on this sample space:

  <fr:tex
display="block"><![CDATA[     E(Y) = \sum _{i=1}^n E(Y \mid  X_i)P(X_i)   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>296</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0012</fr:addr><fr:route>ShanghaiTech-SI140A-0012.xml</fr:route><fr:title
text="Conditional Expectation Given an R.V.">Conditional Expectation Given an R.V.</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X, Y]]></fr:tex> be two random variables. Then the <fr:strong>conditional expectation of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> given <fr:tex
display="inline"><![CDATA[X]]></fr:tex></fr:strong> is a function of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, denoted by <fr:tex
display="inline"><![CDATA[E(Y \mid  X)]]></fr:tex>, defined as:

  <fr:tex
display="block"><![CDATA[     E(Y \mid  X) = \sum _y y P(Y = y \mid  X)   ]]></fr:tex>

  <fr:tex
display="block"><![CDATA[     E(Y \mid  X) = \int _{-\infty }^{+\infty } y f_{Y \mid  X}(y \mid  x) \, \mathrm {d} y   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>297</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0013</fr:addr><fr:route>ShanghaiTech-SI140A-0013.xml</fr:route><fr:title
text="Adam's Law">Adam's Law</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For any random variables <fr:tex
display="inline"><![CDATA[X, Y]]></fr:tex>:

  <fr:tex
display="block"><![CDATA[     E ( E(Y \mid  X) ) = E(Y)   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>298</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0014</fr:addr><fr:route>ShanghaiTech-SI140A-0014.xml</fr:route><fr:title
text="Conditional Variance">Conditional Variance</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>conditional variance</fr:strong> of a r.v. <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> given <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is defined as

  <fr:tex
display="block"><![CDATA[     \operatorname {Var} (Y \mid  X) = E \left ( (Y - E(Y \mid  X))^2 \mid  X \right )   ]]></fr:tex>

  this is equivalent to:

  <fr:tex
display="block"><![CDATA[     \operatorname {Var} (Y \mid  X) = E(Y^2 \mid  X) - E^2(Y \mid  X)   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>299</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0015</fr:addr><fr:route>ShanghaiTech-SI140A-0015.xml</fr:route><fr:title
text="Eve's Law">Eve's Law</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For any two r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, we have

  <fr:tex
display="block"><![CDATA[     \operatorname {Var}(Y) = E(\operatorname {Var}(Y \mid  X)) + \operatorname {Var}(E(Y \mid  X))   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>300</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0017</fr:addr><fr:route>ShanghaiTech-SI140A-0017.xml</fr:route><fr:title
text="Least Square Estimation">Least Square Estimation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Given a random variable <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and a sample <fr:tex
display="inline"><![CDATA[ X_1, X_2, \dots , X_n]]></fr:tex>, let the cost function be the square of the difference between <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\hat {X}]]></fr:tex>:

  <fr:tex
display="block"><![CDATA[     c(X, \hat {X}) = |X - \hat {X}|^2   ]]></fr:tex>

  The best guess is called the <fr:strong>Least Square Estimator</fr:strong>:</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>301</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-001B</fr:addr><fr:route>ShanghaiTech-SI140A-001B.xml</fr:route><fr:title
text="Recurrent State">Recurrent State</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>State <fr:tex
display="inline"><![CDATA[s]]></fr:tex> of a Markov chain is <fr:strong>recurrent</fr:strong> if starting from <fr:tex
display="inline"><![CDATA[s]]></fr:tex>, the chain will return to <fr:tex
display="inline"><![CDATA[s]]></fr:tex> with probability 1.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>302</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-001C</fr:addr><fr:route>ShanghaiTech-SI140A-001C.xml</fr:route><fr:title
text="Transient State">Transient State</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>State <fr:tex
display="inline"><![CDATA[s]]></fr:tex> of a Markov chain is <fr:strong>transient</fr:strong> if this state is not a <fr:link
type="local"
href="ShanghaiTech-SI140A-001B.xml"
addr="ShanghaiTech-SI140A-001B"
title="Recurrent State">recurrent state</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>303</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-001D</fr:addr><fr:route>ShanghaiTech-SI140A-001D.xml</fr:route><fr:title
text="Irreducible and Reducible Markov Chain">Irreducible and Reducible Markov Chain</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A Markov chain with transition matrix <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> is <fr:strong>irreducible</fr:strong> if for any two states <fr:tex
display="inline"><![CDATA[i]]></fr:tex> and <fr:tex
display="inline"><![CDATA[j]]></fr:tex>, it is possible to go from <fr:tex
display="inline"><![CDATA[i]]></fr:tex> to <fr:tex
display="inline"><![CDATA[j]]></fr:tex> in a finite number of steps (with positive probability).</fr:p><fr:p>That is, for any states <fr:tex
display="inline"><![CDATA[i]]></fr:tex>, <fr:tex
display="inline"><![CDATA[j]]></fr:tex> there is some positive integer n such that the <fr:tex
display="inline"><![CDATA[(i, j)]]></fr:tex> entry of <fr:tex
display="inline"><![CDATA[Q^n]]></fr:tex> is positive.</fr:p><fr:p>A Markov chain that is not irreducible is called <fr:strong>reducible</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>304</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-001F</fr:addr><fr:route>ShanghaiTech-SI140A-001F.xml</fr:route><fr:title
text="Period of a Markov Chain">Period of a Markov Chain</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>305</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-001E</fr:addr><fr:route>ShanghaiTech-SI140A-001E.xml</fr:route><fr:title
text="Period of a State in Markov Chain">Period of a State in Markov Chain</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For a Markov chain with transition matrix <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>, the <fr:strong>period</fr:strong> of a state <fr:tex
display="inline"><![CDATA[i]]></fr:tex> is the greatest common divisor of all integers <fr:tex
display="inline"><![CDATA[n]]></fr:tex> such that the <fr:tex
display="inline"><![CDATA[(i, i)]]></fr:tex> entry of <fr:tex
display="inline"><![CDATA[Q^n]]></fr:tex> is positive.

  <fr:tex
display="block"><![CDATA[     d(i) = \gcd  \{ n \in  \mathbb {N} \mid  (Q^n)_{i, i} > 0 \}   ]]></fr:tex></fr:p><fr:p>If <fr:tex
display="inline"><![CDATA[d(i) = 1]]></fr:tex>, then the state <fr:tex
display="inline"><![CDATA[i]]></fr:tex> is <fr:strong>aperiodic</fr:strong>, otherwise it is <fr:strong>periodic</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>A Markov chain is <fr:strong>periodic</fr:strong> if it is <fr:link
type="local"
href="ShanghaiTech-SI140A-001D.xml"
addr="ShanghaiTech-SI140A-001D"
title="Irreducible and Reducible Markov Chain">irreducible</fr:link> and all states have period greater than 1.</fr:p><fr:p>A Markov chain is <fr:strong>aperiodic</fr:strong> if it is <fr:link
type="local"
href="ShanghaiTech-SI140A-001D.xml"
addr="ShanghaiTech-SI140A-001D"
title="Irreducible and Reducible Markov Chain">irreducible</fr:link> and all states have period 1.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>306</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-001G</fr:addr><fr:route>ShanghaiTech-SI140A-001G.xml</fr:route><fr:title
text="Stationary Distribution of a Markov Chain">Stationary Distribution of a Markov Chain</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>stationary distribution</fr:strong> of a Markov chain is a probability distribution <fr:tex
display="inline"><![CDATA[\boldsymbol {s} = (s_1, s_2, \dots , s_n)]]></fr:tex> such that

  <fr:tex
display="block"><![CDATA[     \sum _{i} s_i q_{i, j} = s_j   ]]></fr:tex>

  or equivalently

  <fr:tex
display="block"><![CDATA[     \boldsymbol {s} Q = \boldsymbol {s}   ]]></fr:tex>

  where <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> is the transition matrix of the Markov chain.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>307</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-001H</fr:addr><fr:route>ShanghaiTech-SI140A-001H.xml</fr:route><fr:title
text="Reversibility of a Markov Chain">Reversibility of a Markov Chain</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A Markov chain is <fr:strong>reversible</fr:strong> if there exists a probability distribution <fr:tex
display="inline"><![CDATA[\boldsymbol {\s } = (s_1, s_2, \dots , s_n)]]></fr:tex> such that

  <fr:tex
display="block"><![CDATA[     s_i > 0, \sum _{i} s_i = 1   ]]></fr:tex>

  and

  <fr:tex
display="block"><![CDATA[     s_i q_{i, j} = s_j q_{j, i}   ]]></fr:tex>

  for all <fr:tex
display="inline"><![CDATA[i, j]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> is the transition matrix of the Markov chain.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree>
  <html:hr
xmlns:html="http://www.w3.org/1999/xhtml" />
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>552</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-Lectures</fr:addr><fr:route>ShanghaiTech-SI140A-Lectures.xml</fr:route><fr:title
text="Lectures">Lectures</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>428</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0001</fr:addr><fr:route>ShanghaiTech-SI140A-0001.xml</fr:route><fr:title
text="No. 5: Continuous Random Variables">No. 5: Continuous Random Variables</fr:title><fr:taxon>Lecture</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>402</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0003</fr:addr><fr:route>ShanghaiTech-SI140A-0003.xml</fr:route><fr:title
text="Continuous Random Variables">Continuous Random Variables</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>An r.v. has a <fr:strong>continuous distribution</fr:strong> if its CDF is differentiable. We also allow there to be endpoints (or finitely many points) where the CDF is continuous but not differentiable, as long as the CDF is differentiable everywhere else. A <fr:strong>continuous random variable</fr:strong> is a random variable with a continuous distribution.</fr:p><fr:p>Unlike PMF of a discrete r.v., the PDF of a continuous r.v. does not give the probability of a particular value.

  <fr:tex
display="block"><![CDATA[     P(X = x) = 0 \text { for all } x   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>403</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0004</fr:addr><fr:route>ShanghaiTech-SI140A-0004.xml</fr:route><fr:title
text="Probability Density Functions">Probability Density Functions</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For a continuous r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> with CDF <fr:tex
display="inline"><![CDATA[F_X(x)]]></fr:tex>, the <fr:strong>probability density function</fr:strong> (PDF, 概率密度函数) of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is defined as

  <fr:tex
display="block"><![CDATA[     f_X(x) = \frac {\mathrm {d}}{\mathrm {d}x} F_X(x)   ]]></fr:tex></fr:p><fr:p>Similarly, the <fr:strong>cumulative distribution function</fr:strong> (CDF, 累积分布函数) of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> can be obtained by integrating the PDF:

  <fr:tex
display="block"><![CDATA[     F_X(x) = \int _{-\infty }^x f_X(t) \; \mathrm {d}t   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>404</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0005</fr:addr><fr:route>ShanghaiTech-SI140A-0005.xml</fr:route><fr:title
text="Validity of Probability Density Functions">Validity of Probability Density Functions</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:link
type="local"
href="ShanghaiTech-SI140A-0004.xml"
addr="ShanghaiTech-SI140A-0004"
title="Probability Density Functions">PDF</fr:link> of a continuous r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> must satisfy the following conditions:
  <fr:ul><fr:li><fr:strong>Non-negativity</fr:strong>: <fr:tex
display="inline"><![CDATA[f_X(x) \geq  0]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[x]]></fr:tex>.</fr:li>
    <fr:li><fr:strong>Normalization</fr:strong>: <fr:tex
display="inline"><![CDATA[\int _{-\infty }^\infty  f_X(x) \; \mathrm {d}x = 1]]></fr:tex>.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>405</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0006</fr:addr><fr:route>ShanghaiTech-SI140A-0006.xml</fr:route><fr:title
text="Law of the Unconscious Statisticians">Law of the Unconscious Statisticians</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Discrete Case</fr:strong>:
  <fr:tex
display="block"><![CDATA[     E(g(X)) = \sum _{x} g(x) P(X = x)   ]]></fr:tex></fr:p><fr:p><fr:strong>Continuous Case</fr:strong>:
  <fr:tex
display="block"><![CDATA[     E(g(X)) = \int _{-\infty }^\infty  g(x) f_X(x) \; \mathrm {d}x   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>406</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0007</fr:addr><fr:route>ShanghaiTech-SI140A-0007.xml</fr:route><fr:title
text="Standard Normal Distribution">Standard Normal Distribution</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A continuous r.v. <fr:tex
display="inline"><![CDATA[Z]]></fr:tex> is said to have a <fr:strong>standard normal distribution</fr:strong> if its PDF <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> is given by:

  <fr:tex
display="block"><![CDATA[     \varphi (z) = \frac {1}{\sqrt {2\pi }} e^{-z^2/2}   ]]></fr:tex></fr:p><fr:p>The <fr:strong>standard normal CDF</fr:strong> <fr:tex
display="inline"><![CDATA[\Phi ]]></fr:tex> is given by:
  
  <fr:tex
display="block"><![CDATA[     \Phi (z) = \int _{-\infty }^z \varphi (t) dt   ]]></fr:tex></fr:p><fr:p>Standard normal distribution is denoted by <fr:tex
display="inline"><![CDATA[Z \sim  N(0, 1)]]></fr:tex>. The expectation and variance of a standard normal r.v. are <fr:tex
display="inline"><![CDATA[0]]></fr:tex> and <fr:tex
display="inline"><![CDATA[1]]></fr:tex> respectively.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>407</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0008</fr:addr><fr:route>ShanghaiTech-SI140A-0008.xml</fr:route><fr:title
text="Normal Distribution">Normal Distribution</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[Z]]></fr:tex> is a r.v with <fr:link
type="local"
href="ShanghaiTech-SI140A-0007.xml"
addr="ShanghaiTech-SI140A-0007"
title="Standard Normal Distribution">standard normal distribution</fr:link>, then
  <fr:tex
display="block"><![CDATA[     X = \mu  + \sigma  Z   ]]></fr:tex>
  is said to have the <fr:strong>normal distribution</fr:strong> with mean <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex> and variance <fr:tex
display="inline"><![CDATA[\sigma ^2]]></fr:tex>.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[X \sim  N(\mu , \sigma ^2)]]></fr:tex>, the CDF of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is
  <fr:tex
display="block"><![CDATA[     F(x) = \Phi \left (\frac {x - \mu }{\sigma }\right )   ]]></fr:tex>
  where <fr:tex
display="inline"><![CDATA[\Phi ]]></fr:tex> is the CDF of the standard normal distribution.</fr:p><fr:p>The PDF of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is
  <fr:tex
display="block"><![CDATA[     f(x) = \frac {1}{\sigma } \varphi \left (\frac {x - \mu }{\sigma }\right )   ]]></fr:tex>
  where <fr:tex
display="inline"><![CDATA[\phi ]]></fr:tex> is the PDF of the standard normal distribution.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>408</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0009</fr:addr><fr:route>ShanghaiTech-SI140A-0009.xml</fr:route><fr:title
text="Central Limit Theorem">Central Limit Theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X_1, X_2, \ldots , X_n]]></fr:tex> be a sequence of i.i.d r.v with finite mean <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex> and variance <fr:tex
display="inline"><![CDATA[\sigma ^2]]></fr:tex>, the sample mean is defined as
  <fr:tex
display="block"><![CDATA[     \bar {X} = \frac {1}{n} \sum _{i=1}^n X_i   ]]></fr:tex>
  Then, as <fr:tex
display="inline"><![CDATA[n \to  \infty ]]></fr:tex>,

  <fr:tex
display="block"><![CDATA[     \sqrt {n} \left ( \frac {\bar {X} - \mu }{\sigma ^2} \right ) \to  N(0, 1)   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>409</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000A</fr:addr><fr:route>ShanghaiTech-SI140A-000A.xml</fr:route><fr:title
text="Moment Generating Functions">Moment Generating Functions</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>Moment Generating Function</fr:strong> (MGF) of a random variable <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is defined as

  <fr:tex
display="block"><![CDATA[     M(t) = E(e^{tX})   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>410</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000B</fr:addr><fr:route>ShanghaiTech-SI140A-000B.xml</fr:route><fr:title
text="Moments via Derivatives of the MGF">Moments via Derivatives of the MGF</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Given MGF <fr:tex
display="inline"><![CDATA[M(t)]]></fr:tex> of a random variable <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, the <fr:tex
display="inline"><![CDATA[n]]></fr:tex>-th moment of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is given by

  <fr:tex
display="block"><![CDATA[     E(X^n) = M^{(n)}(0)   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>411</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000C</fr:addr><fr:route>ShanghaiTech-SI140A-000C.xml</fr:route><fr:title
text="MGF of A Sum of Independent R.V.s">MGF of A Sum of Independent R.V.s</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> are independent, then the MGF of their sum is the product of their MGFs.

  <fr:tex
display="block"><![CDATA[     M_{X+Y}(t) = M_X(t) \cdot  M_Y(t)   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>412</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000D</fr:addr><fr:route>ShanghaiTech-SI140A-000D.xml</fr:route><fr:title
text="MGF of Location-scale Transformation">MGF of Location-scale Transformation</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a random variable with MGF <fr:tex
display="inline"><![CDATA[M_X(t)]]></fr:tex>, then the MGF of <fr:tex
display="inline"><![CDATA[a X + b]]></fr:tex> is

  <fr:tex
display="block"><![CDATA[     E(e^{t(a X + b)}) = e^{b t} M_X(a t)   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>429</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000E</fr:addr><fr:route>ShanghaiTech-SI140A-000E.xml</fr:route><fr:title
text="No. 6: Joint Distribution">No. 6: Joint Distribution</fr:title><fr:taxon>Lecture</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>250</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000F</fr:addr><fr:route>ShanghaiTech-SI140A-000F.xml</fr:route><fr:title
text="Joint CDF">Joint CDF</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>joint cumulative distribution function</fr:strong> (CDF) of two random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is defined as

  <fr:tex
display="block"><![CDATA[     F_{X, Y}(x, y) = P(X \leq  x, Y \leq  y)   ]]></fr:tex>

  This can be extended to multiple random variables.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>251</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000G</fr:addr><fr:route>ShanghaiTech-SI140A-000G.xml</fr:route><fr:title
text="Joint PMF">Joint PMF</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>Joint PMF</fr:strong> of two discrete random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is defined as

  <fr:tex
display="block"><![CDATA[     p_{X,Y}(x,y) = \Pr (X = x, Y = y)   ]]></fr:tex>

  Joint PMF of multiple random variables can be defined similarly.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>252</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000H</fr:addr><fr:route>ShanghaiTech-SI140A-000H.xml</fr:route><fr:title
text="Marginal PMF">Marginal PMF</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For discrete r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, the marginal PMF of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is

  <fr:tex
display="block"><![CDATA[     P(X = x) = \sum _y P(X = x, Y = y)   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>253</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000I</fr:addr><fr:route>ShanghaiTech-SI140A-000I.xml</fr:route><fr:title
text="Conditional PMF">Conditional PMF</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For discrete r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, the conditional PMF of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> given <fr:tex
display="inline"><![CDATA[Y = y]]></fr:tex> is

  <fr:tex
display="block"><![CDATA[     P_{X \mid  Y}(x \mid  y) = P(X = x \mid  Y = y) = \frac {P(X = x, Y = y)}{P(Y = y)}   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>254</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000J</fr:addr><fr:route>ShanghaiTech-SI140A-000J.xml</fr:route><fr:title
text="Independence of Discrete R.V.s">Independence of Discrete R.V.s</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Discrete r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> are <fr:strong>independent</fr:strong> if
  <fr:tex
display="block"><![CDATA[     F_{X, Y}(x, y) = F_X(x) F_Y(y)   ]]></fr:tex>
  and it is also equivalent to the condition:
  <fr:tex
display="block"><![CDATA[     P(Y = y \mid  X = x) = P(Y = y)   ]]></fr:tex>
  for all <fr:tex
display="inline"><![CDATA[y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x]]></fr:tex> s.t. <fr:tex
display="inline"><![CDATA[P(X = x) > 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>255</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000K</fr:addr><fr:route>ShanghaiTech-SI140A-000K.xml</fr:route><fr:title
text="Related Theorem">Related Theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[X \sim  \operatorname {Pois}(\lambda  p)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y \sim  \operatorname {Pois}(\lambda  (1 - p))]]></fr:tex> are independent, then <fr:tex
display="inline"><![CDATA[X + Y \sim  \operatorname {Pois}(\lambda )]]></fr:tex> and <fr:tex
display="inline"><![CDATA[X \mid  (X + Y = n) \sim  \operatorname {Bin}(n, p)]]></fr:tex>.</fr:p><fr:p>If <fr:tex
display="inline"><![CDATA[N \sim  \operatorname {Pois}(\lambda )]]></fr:tex> and <fr:tex
display="inline"><![CDATA[X \mid  N = n \sim  \operatorname {Bin}(n, p)]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[X \sim  \operatorname {Pois}(\lambda  p)]]></fr:tex>, <fr:tex
display="inline"><![CDATA[Y = N - X \sim  \operatorname {Pois}(\lambda  (1 - p))]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> are independent.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>256</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000L</fr:addr><fr:route>ShanghaiTech-SI140A-000L.xml</fr:route><fr:title
text="Joint PDF">Joint PDF</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> are continuous with joint CDF <fr:tex
display="inline"><![CDATA[F_{X, Y}]]></fr:tex>, then the joint PDF of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is
  
  <fr:tex
display="block"><![CDATA[     f_{X, Y}(x, y) = \frac {\partial ^2 F_{X, Y}}{\partial  x \partial  y}   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>257</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000M</fr:addr><fr:route>ShanghaiTech-SI140A-000M.xml</fr:route><fr:title
text="Marginal PDF">Marginal PDF</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For continuous random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, the <fr:strong>marginal probability density function</fr:strong> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is

  <fr:tex
display="block"><![CDATA[     f_X(x) = \int _{-\infty }^\infty  f_{X, Y}(x, y) \; \mathrm {d}y   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>258</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000N</fr:addr><fr:route>ShanghaiTech-SI140A-000N.xml</fr:route><fr:title
text="Conditional PDF">Conditional PDF</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For continuous random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, the <fr:strong>conditional probability density function</fr:strong> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> given <fr:tex
display="inline"><![CDATA[Y = y]]></fr:tex> is

  <fr:tex
display="block"><![CDATA[     f_{X \mid  Y}(x \mid  y) = \frac {f_{X, Y}(x, y)}{f_Y(y)}   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>259</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000O</fr:addr><fr:route>ShanghaiTech-SI140A-000O.xml</fr:route><fr:title
text="Independence of Continuous R.V.s">Independence of Continuous R.V.s</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Continuous random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> are <fr:strong>independent</fr:strong> if:
  
  <fr:tex
display="block"><![CDATA[     f_{X, Y}(x, y) = f_X(x) f_Y(y)   ]]></fr:tex>

  It is also equivalent to:

  <fr:tex
display="block"><![CDATA[     f_{X \mid  Y}(x \mid  y) = f_X(x) \quad  \text {and} \quad  f_{Y \mid  X}(y \mid  x) = f_Y(y)   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>260</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000P</fr:addr><fr:route>ShanghaiTech-SI140A-000P.xml</fr:route><fr:title
text="2D LOTUS">2D LOTUS</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be two random variables, <fr:tex
display="inline"><![CDATA[g: \mathbb {R}^2 \mapsto  \mathbb {R}]]></fr:tex>, then:

  <fr:tex
display="block"><![CDATA[     E[g(X, Y)] = \int _{-\infty }^{+\infty } \int _{-\infty }^{+\infty } g(x, y) f_{X, Y}(x, y) \, \mathrm {d}x \, \mathrm {d}y   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>261</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000Q</fr:addr><fr:route>ShanghaiTech-SI140A-000Q.xml</fr:route><fr:title
text="Covariance">Covariance</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>covariance</fr:strong> of two random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is defined as

  <fr:tex
display="block"><![CDATA[     \operatorname {Cov} (X, Y) = E ((X - E(X)) (Y - E(Y))) = E(XY) - E(X) E(Y)   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>262</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000R</fr:addr><fr:route>ShanghaiTech-SI140A-000R.xml</fr:route><fr:title
text="Properties of Covariance">Properties of Covariance</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="ShanghaiTech-SI140A-000Q.xml"
addr="ShanghaiTech-SI140A-000Q"
title="Covariance">Definotion of covariance</fr:link></fr:p><fr:ul><fr:li><fr:tex
display="inline"><![CDATA[\operatorname {Cov}(X, X) = \operatorname {Var}(X)]]></fr:tex></fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[\operatorname {Cov}(X, Y) = \operatorname {Cov}(Y, X)]]></fr:tex></fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[\operatorname {Cov}(X, c) = 0]]></fr:tex> for any constant <fr:tex
display="inline"><![CDATA[c]]></fr:tex></fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[\operatorname {Cov}(c X, Y) = c \operatorname {Cov}(X, Y)]]></fr:tex> for any constant <fr:tex
display="inline"><![CDATA[c]]></fr:tex></fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[\operatorname {Cov}(X + Y, Z) = \operatorname {Cov}(X, Z) + \operatorname {Cov}(Y, Z)]]></fr:tex></fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[\operatorname {Var}(X + Y) = \operatorname {Var}(X) + \operatorname {Var}(Y) + 2 \operatorname {Cov}(X, Y)]]></fr:tex></fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>263</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000S</fr:addr><fr:route>ShanghaiTech-SI140A-000S.xml</fr:route><fr:title
text="Correlation">Correlation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>correlation</fr:strong> between two random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is

  <fr:tex
display="block"><![CDATA[     \operatorname {Corr} (X, Y) = \frac {\operatorname {Cov} (X, Y)}{\sqrt {\operatorname {Var} (X) \operatorname {Var} (Y)}}   ]]></fr:tex></fr:p><fr:p>For any two random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>:

  <fr:tex
display="block"><![CDATA[     -1 \leq  \operatorname {Corr} (X, Y) \leq  1   ]]></fr:tex>

  If <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> are independent, then <fr:tex
display="inline"><![CDATA[\operatorname {Corr} (X, Y) = 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>264</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000T</fr:addr><fr:route>ShanghaiTech-SI140A-000T.xml</fr:route><fr:title
text="Change of Variables">Change of Variables</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Case of one demension</fr:strong>: Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a continuous random variable with PDF <fr:tex
display="inline"><![CDATA[f_X(x)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y = g(X)]]></fr:tex> be a function of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> with inverse <fr:tex
display="inline"><![CDATA[X = g^{-1}(Y)]]></fr:tex>. Then the PDF of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is

  <fr:tex
display="block"><![CDATA[     f_Y(y) = f_X(g^{-1}(y)) \left | \frac {\mathrm {d}}{\mathrm {d}y} g^{-1}(y) \right |   ]]></fr:tex></fr:p><fr:p><fr:strong>Case of multiple dimensions</fr:strong>: 
  
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>265</fr:anchor><fr:addr
type="user">concept-0009</fr:addr><fr:route>concept-0009.xml</fr:route><fr:title
text="Jacobian Matrix">Jacobian Matrix</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If a function <fr:tex
display="inline"><![CDATA[\boldsymbol {f}: \mathbb {R}^n \mapsto  \mathbb {R}^m]]></fr:tex> is differentiable at <fr:tex
display="inline"><![CDATA[\boldsymbol {x} \in  \mathbb {R}^n]]></fr:tex>, then the Jacobian matrix of <fr:tex
display="inline"><![CDATA[\boldsymbol {f}]]></fr:tex> at <fr:tex
display="inline"><![CDATA[\boldsymbol {x}]]></fr:tex> is the best linear approximation of <fr:tex
display="inline"><![CDATA[\boldsymbol {f}]]></fr:tex> at <fr:tex
display="inline"><![CDATA[\boldsymbol {x}]]></fr:tex>. It is defined as

  <fr:tex
display="block"><![CDATA[     \frac {\partial  \boldsymbol {f}}{\partial  \boldsymbol {x}} =     \begin {bmatrix}       \frac {\partial  f_1}{\partial  x_1} & \cdots  & \frac {\partial  f_1}{\partial  x_n} \\       \vdots  & \ddots  & \vdots  \\       \frac {\partial  f_m}{\partial  x_1} & \cdots  & \frac {\partial  f_m}{\partial  x_n}     \end {bmatrix}   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

  Let <fr:tex
display="inline"><![CDATA[\boldsymbol {X}]]></fr:tex> be a continuous random vector with PDF <fr:tex
display="inline"><![CDATA[f_{\boldsymbol {X}}(\boldsymbol {x})]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\boldsymbol {Y} = \boldsymbol {g}(\boldsymbol {X})]]></fr:tex> be a function of <fr:tex
display="inline"><![CDATA[\boldsymbol {X}]]></fr:tex> with inverse <fr:tex
display="inline"><![CDATA[\boldsymbol {X} = \boldsymbol {g}^{-1}(\boldsymbol {Y})]]></fr:tex>. Then the PDF of <fr:tex
display="inline"><![CDATA[\boldsymbol {Y}]]></fr:tex> is

  <fr:tex
display="block"><![CDATA[     f_{\boldsymbol {Y}}(\boldsymbol {y}) = f_{\boldsymbol {X}}(\boldsymbol {g}^{-1}(\boldsymbol {y})) \left | \det  \left ( \frac {\partial  \boldsymbol {g}^{-1}(\boldsymbol {y})}{\partial  \boldsymbol {y}} \right ) \right |   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>430</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000U</fr:addr><fr:route>ShanghaiTech-SI140A-000U.xml</fr:route><fr:title
text="No. 7: Monte Carlo">No. 7: Monte Carlo</fr:title><fr:taxon>Lecture</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>322</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000V</fr:addr><fr:route>ShanghaiTech-SI140A-000V.xml</fr:route><fr:title
text="Cauchy-Schwarz Inequality (Probability Theory)">Cauchy-Schwarz Inequality (Probability Theory)</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>290</fr:anchor><fr:addr
type="user">concept-000A</fr:addr><fr:route>concept-000A.xml</fr:route><fr:title
text="Cauchy-Schwarz Inequality">Cauchy-Schwarz Inequality</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>Cauchy-Schwarz inequality</fr:strong> states that for all vectors <fr:tex
display="inline"><![CDATA[\boldsymbol {a}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\boldsymbol {b}]]></fr:tex> in a inner product space, the following inequality holds:

  <fr:tex
display="block"><![CDATA[     \left | \langle  \boldsymbol {a}, \boldsymbol {b} \rangle  \right |^2 \leq  \langle  \boldsymbol {a}, \boldsymbol {a} \rangle  \cdot  \langle  \boldsymbol {b}, \boldsymbol {b} \rangle    ]]></fr:tex>

  where <fr:tex
display="inline"><![CDATA[\langle  \cdot , \cdot  \rangle ]]></fr:tex> is the inner product.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>In probability theory, we define an inner product between two random variables <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> as

  <fr:tex
display="block"><![CDATA[     \langle  X, Y \rangle  = E (X Y)   ]]></fr:tex>

  the Cauchy-Schwarz inequality states that

  <fr:tex
display="block"><![CDATA[     |E(XY)| \leq  \sqrt {E(X^2) E(Y^2)}   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>323</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000W</fr:addr><fr:route>ShanghaiTech-SI140A-000W.xml</fr:route><fr:title
text="Markov's Inequality">Markov's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For any r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and constant <fr:tex
display="inline"><![CDATA[a > 0]]></fr:tex>, we have

  <fr:tex
display="block"><![CDATA[     P(|X| \geq  a) \leq  \frac {E|X|}{a}   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>324</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000X</fr:addr><fr:route>ShanghaiTech-SI140A-000X.xml</fr:route><fr:title
text="Chebyshev's Inequality">Chebyshev's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a r.v. with finite mean <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex> and finite variance <fr:tex
display="inline"><![CDATA[\sigma ^2]]></fr:tex>. Then for any constant <fr:tex
display="inline"><![CDATA[a > 0]]></fr:tex>, we have

  <fr:tex
display="block"><![CDATA[     P(|X - \mu | \geq  a) \leq  \frac {\sigma ^2}{a^2}   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>325</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000Y</fr:addr><fr:route>ShanghaiTech-SI140A-000Y.xml</fr:route><fr:title
text="Chernoff's Inequality">Chernoff's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For any r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and constants <fr:tex
display="inline"><![CDATA[a, t > 0]]></fr:tex>, we have

  <fr:tex
display="block"><![CDATA[     P(X \geq  a) \leq  \frac {E(e^{tX})}{e^{ta}}   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>326</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-000Z</fr:addr><fr:route>ShanghaiTech-SI140A-000Z.xml</fr:route><fr:title
text="Hoeffding Bound">Hoeffding Bound</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let the r.v. s <fr:tex
display="inline"><![CDATA[X_1, X_2, \dots , X_n]]></fr:tex> be i.i.d. with <fr:tex
display="inline"><![CDATA[\E (X_i) = \mu ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[a \leq  X_i \leq  b]]></fr:tex>. Then, for any <fr:tex
display="inline"><![CDATA[\epsilon  > 0]]></fr:tex>,

  <fr:tex
display="block"><![CDATA[     P \left ( \left | \frac {1}{n} \sum _{i=1}^n X_i - \mu  \right | \geq  \epsilon  \right ) \leq  2 \exp  \left ( - \frac {2n \epsilon ^2}{(b-a)^2} \right )   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>431</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0010</fr:addr><fr:route>ShanghaiTech-SI140A-0010.xml</fr:route><fr:title
text="No. 8: Conditional Expectation">No. 8: Conditional Expectation</fr:title><fr:taxon>Lecture</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>310</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0011</fr:addr><fr:route>ShanghaiTech-SI140A-0011.xml</fr:route><fr:title
text="Law of Total Expectation">Law of Total Expectation</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X_1, X_2, \dots , X_n]]></fr:tex> be a partition of the sample space, s.t. <fr:tex
display="inline"><![CDATA[P(X_i) > 0]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[i]]></fr:tex>. Then for any random variable <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> on this sample space:

  <fr:tex
display="block"><![CDATA[     E(Y) = \sum _{i=1}^n E(Y \mid  X_i)P(X_i)   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>311</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0012</fr:addr><fr:route>ShanghaiTech-SI140A-0012.xml</fr:route><fr:title
text="Conditional Expectation Given an R.V.">Conditional Expectation Given an R.V.</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X, Y]]></fr:tex> be two random variables. Then the <fr:strong>conditional expectation of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> given <fr:tex
display="inline"><![CDATA[X]]></fr:tex></fr:strong> is a function of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, denoted by <fr:tex
display="inline"><![CDATA[E(Y \mid  X)]]></fr:tex>, defined as:

  <fr:tex
display="block"><![CDATA[     E(Y \mid  X) = \sum _y y P(Y = y \mid  X)   ]]></fr:tex>

  <fr:tex
display="block"><![CDATA[     E(Y \mid  X) = \int _{-\infty }^{+\infty } y f_{Y \mid  X}(y \mid  x) \, \mathrm {d} y   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>312</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0013</fr:addr><fr:route>ShanghaiTech-SI140A-0013.xml</fr:route><fr:title
text="Adam's Law">Adam's Law</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For any random variables <fr:tex
display="inline"><![CDATA[X, Y]]></fr:tex>:

  <fr:tex
display="block"><![CDATA[     E ( E(Y \mid  X) ) = E(Y)   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>313</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0014</fr:addr><fr:route>ShanghaiTech-SI140A-0014.xml</fr:route><fr:title
text="Conditional Variance">Conditional Variance</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>conditional variance</fr:strong> of a r.v. <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> given <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is defined as

  <fr:tex
display="block"><![CDATA[     \operatorname {Var} (Y \mid  X) = E \left ( (Y - E(Y \mid  X))^2 \mid  X \right )   ]]></fr:tex>

  this is equivalent to:

  <fr:tex
display="block"><![CDATA[     \operatorname {Var} (Y \mid  X) = E(Y^2 \mid  X) - E^2(Y \mid  X)   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>314</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0015</fr:addr><fr:route>ShanghaiTech-SI140A-0015.xml</fr:route><fr:title
text="Eve's Law">Eve's Law</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For any two r.v. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, we have

  <fr:tex
display="block"><![CDATA[     \operatorname {Var}(Y) = E(\operatorname {Var}(Y \mid  X)) + \operatorname {Var}(E(Y \mid  X))   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>315</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0016</fr:addr><fr:route>ShanghaiTech-SI140A-0016.xml</fr:route><fr:title
text="Estimation (Basic Problem)">Estimation (Basic Problem)</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Given a random variable <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and a sample <fr:tex
display="inline"><![CDATA[ X_1, X_2, \dots , X_n]]></fr:tex> we want to estimate the distribution of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p><fr:p>The <fr:strong>Estimator</fr:strong> is a function <fr:tex
display="inline"><![CDATA[\hat {X} = g(X_1, X_2, \dots , X_n)]]></fr:tex>. The <fr:strong>cost function</fr:strong> is a function <fr:tex
display="inline"><![CDATA[c(X, \hat {X})]]></fr:tex> that measures the quality of the estimator. We want to minimize the expected cost <fr:tex
display="inline"><![CDATA[E(c(X, \hat {X}))]]></fr:tex>.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>316</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0017</fr:addr><fr:route>ShanghaiTech-SI140A-0017.xml</fr:route><fr:title
text="Least Square Estimation">Least Square Estimation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Given a random variable <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and a sample <fr:tex
display="inline"><![CDATA[ X_1, X_2, \dots , X_n]]></fr:tex>, let the cost function be the square of the difference between <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\hat {X}]]></fr:tex>:

  <fr:tex
display="block"><![CDATA[     c(X, \hat {X}) = |X - \hat {X}|^2   ]]></fr:tex>

  The best guess is called the <fr:strong>Least Square Estimator</fr:strong>:</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>317</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0018</fr:addr><fr:route>ShanghaiTech-SI140A-0018.xml</fr:route><fr:title
text="Linear Least Square Estimation">Linear Least Square Estimation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If the estimator in a LSE estimation is <fr:strong>linear</fr:strong>, then it is called a <fr:strong>Linear Least Square Estimator (LLSE)</fr:strong>.</fr:p><fr:p>The LLSE of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> given <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, denoted by <fr:tex
display="inline"><![CDATA[L [Y \mid  X] ]]></fr:tex> is the linear function <fr:tex
display="inline"><![CDATA[a + b X]]></fr:tex> that minimizes the mean square error <fr:tex
display="inline"><![CDATA[E[(Y - a - b X)^2]]]></fr:tex>.

  <fr:tex
display="block"><![CDATA[     L [Y \mid  X] = E[Y] + \frac {\operatorname {Cov}(X, Y)}{\operatorname {Var}(X)} (X - E[X])   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>318</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-0019</fr:addr><fr:route>ShanghaiTech-SI140A-0019.xml</fr:route><fr:title
text="Minimum Mean Square Estimation">Minimum Mean Square Estimation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If the estimator is an arbitrary function, and the cost function is the mean square error, then the estimator is called a <fr:strong>Minimum Mean Square Estimator (MMSE)</fr:strong>.</fr:p><fr:p>The MMSE of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> given <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is given by the conditional expectation:

  <fr:tex
display="block"><![CDATA[     E[Y \mid  X]   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>432</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-001A</fr:addr><fr:route>ShanghaiTech-SI140A-001A.xml</fr:route><fr:title
text="No. 9: Markov Chain">No. 9: Markov Chain</fr:title><fr:taxon>Lecture</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Refer to <fr:link
type="external"
href="https://zhuanlan.zhihu.com/p/14070878026">my post on zhihu</fr:link>.</fr:p><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>373</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-001B</fr:addr><fr:route>ShanghaiTech-SI140A-001B.xml</fr:route><fr:title
text="Recurrent State">Recurrent State</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>State <fr:tex
display="inline"><![CDATA[s]]></fr:tex> of a Markov chain is <fr:strong>recurrent</fr:strong> if starting from <fr:tex
display="inline"><![CDATA[s]]></fr:tex>, the chain will return to <fr:tex
display="inline"><![CDATA[s]]></fr:tex> with probability 1.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>374</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-001C</fr:addr><fr:route>ShanghaiTech-SI140A-001C.xml</fr:route><fr:title
text="Transient State">Transient State</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>State <fr:tex
display="inline"><![CDATA[s]]></fr:tex> of a Markov chain is <fr:strong>transient</fr:strong> if this state is not a <fr:link
type="local"
href="ShanghaiTech-SI140A-001B.xml"
addr="ShanghaiTech-SI140A-001B"
title="Recurrent State">recurrent state</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>375</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-001D</fr:addr><fr:route>ShanghaiTech-SI140A-001D.xml</fr:route><fr:title
text="Irreducible and Reducible Markov Chain">Irreducible and Reducible Markov Chain</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A Markov chain with transition matrix <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> is <fr:strong>irreducible</fr:strong> if for any two states <fr:tex
display="inline"><![CDATA[i]]></fr:tex> and <fr:tex
display="inline"><![CDATA[j]]></fr:tex>, it is possible to go from <fr:tex
display="inline"><![CDATA[i]]></fr:tex> to <fr:tex
display="inline"><![CDATA[j]]></fr:tex> in a finite number of steps (with positive probability).</fr:p><fr:p>That is, for any states <fr:tex
display="inline"><![CDATA[i]]></fr:tex>, <fr:tex
display="inline"><![CDATA[j]]></fr:tex> there is some positive integer n such that the <fr:tex
display="inline"><![CDATA[(i, j)]]></fr:tex> entry of <fr:tex
display="inline"><![CDATA[Q^n]]></fr:tex> is positive.</fr:p><fr:p>A Markov chain that is not irreducible is called <fr:strong>reducible</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>376</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-001F</fr:addr><fr:route>ShanghaiTech-SI140A-001F.xml</fr:route><fr:title
text="Period of a Markov Chain">Period of a Markov Chain</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>305</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-001E</fr:addr><fr:route>ShanghaiTech-SI140A-001E.xml</fr:route><fr:title
text="Period of a State in Markov Chain">Period of a State in Markov Chain</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For a Markov chain with transition matrix <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>, the <fr:strong>period</fr:strong> of a state <fr:tex
display="inline"><![CDATA[i]]></fr:tex> is the greatest common divisor of all integers <fr:tex
display="inline"><![CDATA[n]]></fr:tex> such that the <fr:tex
display="inline"><![CDATA[(i, i)]]></fr:tex> entry of <fr:tex
display="inline"><![CDATA[Q^n]]></fr:tex> is positive.

  <fr:tex
display="block"><![CDATA[     d(i) = \gcd  \{ n \in  \mathbb {N} \mid  (Q^n)_{i, i} > 0 \}   ]]></fr:tex></fr:p><fr:p>If <fr:tex
display="inline"><![CDATA[d(i) = 1]]></fr:tex>, then the state <fr:tex
display="inline"><![CDATA[i]]></fr:tex> is <fr:strong>aperiodic</fr:strong>, otherwise it is <fr:strong>periodic</fr:strong>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>A Markov chain is <fr:strong>periodic</fr:strong> if it is <fr:link
type="local"
href="ShanghaiTech-SI140A-001D.xml"
addr="ShanghaiTech-SI140A-001D"
title="Irreducible and Reducible Markov Chain">irreducible</fr:link> and all states have period greater than 1.</fr:p><fr:p>A Markov chain is <fr:strong>aperiodic</fr:strong> if it is <fr:link
type="local"
href="ShanghaiTech-SI140A-001D.xml"
addr="ShanghaiTech-SI140A-001D"
title="Irreducible and Reducible Markov Chain">irreducible</fr:link> and all states have period 1.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>377</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-001G</fr:addr><fr:route>ShanghaiTech-SI140A-001G.xml</fr:route><fr:title
text="Stationary Distribution of a Markov Chain">Stationary Distribution of a Markov Chain</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>stationary distribution</fr:strong> of a Markov chain is a probability distribution <fr:tex
display="inline"><![CDATA[\boldsymbol {s} = (s_1, s_2, \dots , s_n)]]></fr:tex> such that

  <fr:tex
display="block"><![CDATA[     \sum _{i} s_i q_{i, j} = s_j   ]]></fr:tex>

  or equivalently

  <fr:tex
display="block"><![CDATA[     \boldsymbol {s} Q = \boldsymbol {s}   ]]></fr:tex>

  where <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> is the transition matrix of the Markov chain.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>378</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-001H</fr:addr><fr:route>ShanghaiTech-SI140A-001H.xml</fr:route><fr:title
text="Reversibility of a Markov Chain">Reversibility of a Markov Chain</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A Markov chain is <fr:strong>reversible</fr:strong> if there exists a probability distribution <fr:tex
display="inline"><![CDATA[\boldsymbol {\s } = (s_1, s_2, \dots , s_n)]]></fr:tex> such that

  <fr:tex
display="block"><![CDATA[     s_i > 0, \sum _{i} s_i = 1   ]]></fr:tex>

  and

  <fr:tex
display="block"><![CDATA[     s_i q_{i, j} = s_j q_{j, i}   ]]></fr:tex>

  for all <fr:tex
display="inline"><![CDATA[i, j]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> is the transition matrix of the Markov chain.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>433</fr:anchor><fr:addr
type="user">ShanghaiTech-SI140A-001I</fr:addr><fr:route>ShanghaiTech-SI140A-001I.xml</fr:route><fr:title
text="No. 10: Statistical Inference">No. 10: Statistical Inference</fr:title><fr:taxon>Lecture</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Not very reasonable beacuse of the chaotic conventions in the slides.</fr:p><fr:p>This is a weird way to think of it (爸爸像儿子), but you can think of this part as being the same as machine learning algorithms.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>615</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-index</fr:addr><fr:route>ShanghaiTech-CS101-index.xml</fr:route><fr:title
text="Courses › Algorithm &amp; DS Fall 2024"><fr:link
type="local"
href="ShanghaiTech-Courses.xml"
addr="ShanghaiTech-Courses"
title="Courses">Courses</fr:link> › Algorithm &amp; DS Fall 2024</fr:title><fr:taxon>Course</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>7</fr:day></fr:date><fr:authors /><fr:meta
name="external">https://i-techx.github.io/iTechX/courses?course_code=CS101</fr:meta></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>539</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-Concepts</fr:addr><fr:route>ShanghaiTech-CS101-Concepts.xml</fr:route><fr:title
text="Concepts and definitions">Concepts and definitions</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>536</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-0002</fr:addr><fr:route>ShanghaiTech-CS101-0002.xml</fr:route><fr:title
text="Disjoint Set">Disjoint Set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Disjoint set（并查集） is a data structure that keeps track of equivalence classes of all elements in a set.

  It supports two operations:

  <fr:ul><fr:li><fr:code>find(x)</fr:code>: return the representative of the set that element <fr:tex
display="inline"><![CDATA[x]]></fr:tex> belongs to.</fr:li>
    <fr:li><fr:code>union(x, y)</fr:code>: merge the sets that contain <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex>.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>537</fr:anchor><fr:addr
type="user">concept-0002</fr:addr><fr:route>concept-0002.xml</fr:route><fr:title
text="Graph">Graph</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>graph</fr:strong> is a collection of vertices and edges. An edge connects two vertices. We can represent a graph as <fr:tex
display="inline"><![CDATA[G = (V, E)]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[V]]></fr:tex> is the set of vertices and <fr:tex
display="inline"><![CDATA[E]]></fr:tex> is the set of edges.</fr:p><fr:p>A graph can be directed or undirected, edge <fr:tex
display="inline"><![CDATA[(u, v)]]></fr:tex> in a directed graph has a direction from <fr:tex
display="inline"><![CDATA[u]]></fr:tex> to <fr:tex
display="inline"><![CDATA[v]]></fr:tex>, while in an undirected graph, the edge has no direction (can be denoted as <fr:tex
display="inline"><![CDATA[\{u, v\}]]></fr:tex>).</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree>
  <html:hr
xmlns:html="http://www.w3.org/1999/xhtml" />
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>540</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-Lectures</fr:addr><fr:route>ShanghaiTech-CS101-Lectures.xml</fr:route><fr:title
text="Lectures">Lectures</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>541</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-0001</fr:addr><fr:route>ShanghaiTech-CS101-0001.xml</fr:route><fr:title
text="No.14 : Disjoint Set">No.14 : Disjoint Set</fr:title><fr:taxon>Lecture</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>542</fr:anchor><fr:addr
type="user">concept-0001</fr:addr><fr:route>concept-0001.xml</fr:route><fr:title
text="Equivalence Relation">Equivalence Relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>An <fr:strong>equivalence relation（等价关系）</fr:strong> is a binary relation <fr:tex
display="inline"><![CDATA[\equiv ]]></fr:tex> on a set <fr:tex
display="inline"><![CDATA[S]]></fr:tex>, such that:

  <fr:ul><fr:li>reflexive: for all <fr:tex
display="inline"><![CDATA[x : S]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x \equiv  x]]></fr:tex></fr:li>
    <fr:li>symmetric: for all <fr:tex
display="inline"><![CDATA[x, y : S]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[x \equiv  y]]></fr:tex> then <fr:tex
display="inline"><![CDATA[y \equiv  x]]></fr:tex></fr:li>
    <fr:li>transitive: for all <fr:tex
display="inline"><![CDATA[x, y, z : S]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[x \equiv  y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y \equiv  z]]></fr:tex> then <fr:tex
display="inline"><![CDATA[x \equiv  z]]></fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

  It's obvious that an equivalence relation can be used to <fr:strong>partition a set into disjoint (not overlapping) subsets</fr:strong>.

  <fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>543</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-0002</fr:addr><fr:route>ShanghaiTech-CS101-0002.xml</fr:route><fr:title
text="Disjoint Set">Disjoint Set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Disjoint set（并查集） is a data structure that keeps track of equivalence classes of all elements in a set.

  It supports two operations:

  <fr:ul><fr:li><fr:code>find(x)</fr:code>: return the representative of the set that element <fr:tex
display="inline"><![CDATA[x]]></fr:tex> belongs to.</fr:li>
    <fr:li><fr:code>union(x, y)</fr:code>: merge the sets that contain <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex>.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

  <fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>544</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-0003</fr:addr><fr:route>ShanghaiTech-CS101-0003.xml</fr:route><fr:title
text="Implementation of Disjoint Set">Implementation of Disjoint Set</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Use an array to store the representative of each element, the structure will be an directed tree where each element points to a representative.

  <html:figure
xmlns:html="http://www.w3.org/1999/xhtml">
    <html:img
src="ShanghaiTech-CS101/dsu.png" />
    <html:figcaption>并查集实现的直观结构：一颗内向树</html:figcaption>
  </html:figure>

  Therefore, the two operations will be:

  <fr:ul><fr:li><fr:code>find :: Eq a =&gt; DisjointSet a -&gt; a -&gt; a</fr:code> : find the representative of an element</fr:li>
    <fr:li><fr:code>union :: Eq a =&gt; DisjointSet a -&gt; a -&gt; a -&gt; DisjointSet a</fr:code> : merge two sets</fr:li></fr:ul>

  Trivially, <fr:code>find</fr:code> recursively finds the root of the tree, and <fr:code>union</fr:code> merges two trees by making one root the child of the other, the time complexity of both operations is <fr:tex
display="inline"><![CDATA[\Omicron  (n)]]></fr:tex> since the height of the tree can be as large as <fr:tex
display="inline"><![CDATA[n]]></fr:tex>.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>545</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-0004</fr:addr><fr:route>ShanghaiTech-CS101-0004.xml</fr:route><fr:title
text="Merge By Rank Optimization">Merge By Rank Optimization</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>To optimize the <fr:link
type="local"
href="ShanghaiTech-CS101-0003.xml"
addr="ShanghaiTech-CS101-0003"
title="Implementation of Disjoint Set">trivial implementation</fr:link> of the union operation, we can use the <fr:strong>merge by rank</fr:strong> optimization.

  Intuitively, we want the height of the tree to be small. Therefore, we can merge the smaller tree into the larger tree to keep the height of the tree small.</fr:p><fr:p><fr:strong>Worst Case</fr:strong>:

  <html:figure
xmlns:html="http://www.w3.org/1999/xhtml">
    <html:img
src="ShanghaiTech-CS101/dsu-worst.png" />
    <html:figcaption>仅使用按秩合并的并查集，最坏情况结构</html:figcaption>
  </html:figure>

  In the worst case, a disjoint set with height <fr:tex
display="inline"><![CDATA[h]]></fr:tex> will have 
  <fr:tex
display="block"><![CDATA[     \sum _{k = 0}^{h} h \binom {h}{k} = h \cdot  2^{h - 1}   ]]></fr:tex>
  elements, which means the depth of a tree will be logarithmic in the number of elements.</fr:p><fr:p><fr:strong>Time Complexity</fr:strong>: <fr:tex
display="inline"><![CDATA[\Omicron  (\log  n)]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>546</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-0005</fr:addr><fr:route>ShanghaiTech-CS101-0005.xml</fr:route><fr:title
text="Path Compression Optimization">Path Compression Optimization</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>To optimize the <fr:link
type="local"
href="ShanghaiTech-CS101-0003.xml"
addr="ShanghaiTech-CS101-0003"
title="Implementation of Disjoint Set">trivial implementation</fr:link> of the union operation, we can use the <fr:strong>path compression optimization</fr:strong>.</fr:p><fr:p>By the definition of the <fr:link
type="local"
href="concept-0001.xml"
addr="concept-0001"
title="Equivalence Relation">equivalence relation</fr:link>, we know that the elements in the same equivalence class can <fr:strong>choose the same element as the representative</fr:strong>. Thus, we can set all the elements in the same equivalence class to point to the same, final representative when we find the representative of an element.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>With the two optimizations above the time complexity of both operations can be reduced to <fr:tex
display="inline"><![CDATA[\Omicron  (\alpha  (n))]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\alpha  (n)]]></fr:tex> is the <fr:link
type="external"
href="https://en.wikipedia.org/wiki/Ackermann_function">inverse Ackermann function</fr:link>, which is a very slow growing function, so the time complexity of both operations is almost <fr:tex
display="inline"><![CDATA[\Theta  (1)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>547</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-0006</fr:addr><fr:route>ShanghaiTech-CS101-0006.xml</fr:route><fr:title
text="No.15 : Graphs">No.15 : Graphs</fr:title><fr:taxon>Lecture</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>520</fr:anchor><fr:addr
type="user">concept-0002</fr:addr><fr:route>concept-0002.xml</fr:route><fr:title
text="Graph">Graph</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>graph</fr:strong> is a collection of vertices and edges. An edge connects two vertices. We can represent a graph as <fr:tex
display="inline"><![CDATA[G = (V, E)]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[V]]></fr:tex> is the set of vertices and <fr:tex
display="inline"><![CDATA[E]]></fr:tex> is the set of edges.</fr:p><fr:p>A graph can be directed or undirected, edge <fr:tex
display="inline"><![CDATA[(u, v)]]></fr:tex> in a directed graph has a direction from <fr:tex
display="inline"><![CDATA[u]]></fr:tex> to <fr:tex
display="inline"><![CDATA[v]]></fr:tex>, while in an undirected graph, the edge has no direction (can be denoted as <fr:tex
display="inline"><![CDATA[\{u, v\}]]></fr:tex>).</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>521</fr:anchor><fr:addr
type="user">concept-0003</fr:addr><fr:route>concept-0003.xml</fr:route><fr:title
text="Degree (graph theory)">Degree (graph theory)</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:strong>degree</fr:strong> of a vertex in a graph is the number of edges incident to the vertex.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>522</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-0007</fr:addr><fr:route>ShanghaiTech-CS101-0007.xml</fr:route><fr:title
text="Subgraph">Subgraph</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>subgraph</fr:strong> of a graph <fr:tex
display="inline"><![CDATA[G = (V, E)]]></fr:tex> is a graph <fr:tex
display="inline"><![CDATA[G' = (V', E')]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[V' \subseteq  V]]></fr:tex> and <fr:tex
display="inline"><![CDATA[E' \subseteq  E, \forall  (u, v) \in  E', u, v \in  V']]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>523</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-0008</fr:addr><fr:route>ShanghaiTech-CS101-0008.xml</fr:route><fr:title
text="Vertex-induced subgraph">Vertex-induced subgraph</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>vertex-induced subgraph</fr:strong> of a graph <fr:tex
display="inline"><![CDATA[G = (V, E)]]></fr:tex> is a graph <fr:tex
display="inline"><![CDATA[G' = (V', E')]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[V' \subseteq  V]]></fr:tex> and <fr:tex
display="inline"><![CDATA[E' = \{(u, v) \in  E \mid  u, v \in  V'\}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>524</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-0009</fr:addr><fr:route>ShanghaiTech-CS101-0009.xml</fr:route><fr:title
text="Path (graph theory)">Path (graph theory)</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:strong>path</fr:strong> in a graph is a sequence of vertices <fr:tex
display="inline"><![CDATA[v_1, v_2, \ldots , v_k]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[(v_i, v_{i+1})]]></fr:tex> is an edge for all <fr:tex
display="inline"><![CDATA[1 \leq  i < k]]></fr:tex>. The length of a path is the number of edges in the path.</fr:p><fr:p><fr:strong>Derivations</fr:strong>:
  <fr:ul><fr:li>Simple path: A path with no repeated vertices.</fr:li>
    <fr:li>Cycle: A path with the same start and end vertices.</fr:li>
    <fr:li>Simple Cycle: A cycle with no repeated vertices except the start and end vertices.</fr:li>
    <fr:li>Path in a graph with weights: the length of a path is the sum of the weights of the edges in the path.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Here are the methods to represent the graph:</fr:p><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>525</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-000A</fr:addr><fr:route>ShanghaiTech-CS101-000A.xml</fr:route><fr:title
text="Binary-relation list">Binary-relation list</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Binary-relation list</fr:strong> is an implementation of a graph. It stores all the edges in a list. Each edge is a pair of vertices.</fr:p><fr:ul><fr:li>Space complexity: <fr:tex
display="inline"><![CDATA[\Theta (|E|)]]></fr:tex></fr:li>
  <fr:li>Time complexity: <fr:tex
display="inline"><![CDATA[\Theta (|E|)]]></fr:tex></fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>526</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-000B</fr:addr><fr:route>ShanghaiTech-CS101-000B.xml</fr:route><fr:title
text="Adjacency Matrix">Adjacency Matrix</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Adjacency matrix</fr:strong> is an implementation of a graph. It uses a matrix to represent the connections between vertices. If <fr:tex
display="inline"><![CDATA[(i, j) \in  E]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[A_{ij} = 1]]></fr:tex>, otherwise <fr:tex
display="inline"><![CDATA[A_{ij} = 0]]></fr:tex>.</fr:p><fr:ul><fr:li>Space complexity: <fr:tex
display="inline"><![CDATA[\Theta (|V|^2)]]></fr:tex></fr:li>
  <fr:li>Time complexity to check if two vertices are connected: <fr:tex
display="inline"><![CDATA[\Omicron (1)]]></fr:tex></fr:li>
  <fr:li>Time complexity to check all neighbors of a vertex: <fr:tex
display="inline"><![CDATA[\Theta (|V|)]]></fr:tex></fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>527</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-000C</fr:addr><fr:route>ShanghaiTech-CS101-000C.xml</fr:route><fr:title
text="Adjacency List">Adjacency List</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Adjacency list</fr:strong> is an implementation of a graph. Each vertex has a list of its neighbors. If <fr:tex
display="inline"><![CDATA[(i, j) \in  E]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[j]]></fr:tex> is in the list of <fr:tex
display="inline"><![CDATA[i]]></fr:tex>.</fr:p><fr:ul><fr:li>Space complexity: <fr:tex
display="inline"><![CDATA[\Theta (|V| + |E|)]]></fr:tex></fr:li>
  <fr:li>Time complexity to check if two vertices are connected: <fr:tex
display="inline"><![CDATA[\Theta (|V|)]]></fr:tex></fr:li>
  <fr:li>Time complexity to check all neighbors of a vertex: <fr:tex
display="inline"><![CDATA[\Theta (\text {degree}(v))]]></fr:tex></fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>548</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-000D</fr:addr><fr:route>ShanghaiTech-CS101-000D.xml</fr:route><fr:title
text="No.16 : Graph Traversal">No.16 : Graph Traversal</fr:title><fr:taxon>Lecture</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>534</fr:anchor><fr:addr
type="user">ShanghaiTech-CS101-000E</fr:addr><fr:route>ShanghaiTech-CS101-000E.xml</fr:route><fr:title
text="Breadth-First Search">Breadth-First Search</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:pre><![CDATA[    function BFS(G, s)
      let Q be a queue
      set s as visited
      Q.enqueue(s)
      while Q is not empty
        v <- Q.dequeue()
        for all edges from v to w in G
          if w is not visited
            set w as visited
            Q.enqueue(w)
      end while
    end function]]></fr:pre></fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>